pragma cashscript ^0.13.0;

/**
 * MeanRevertSingleTokenNFTAuth (PoC)
 *
 * - Tracks a single FT token category for mean reversion.
 * - Rebalance is permitted ONLY if caller provides an NFT with:
 *     * nftCommitment == rebalancerNftCommit
 *     * tokenAmount == 0 (pure NFT)
 *   (Capability and category are NOT currently enforced – category
 *    param is kept for future tightening / productionisation.)
 * - Drain path is still restricted to ownerPkh (Alice) for safe disposal.
 *
 * Params:
 *   tokenCategory        = fungible token for portfolio (VM-order bytes)
 *   targetTokenAmount    = desired total FT amount (oracle / strategy)
 *   rebalancerNftCat     = (reserved) NFT category (currently unused)
 *   rebalancerNftCommit  = NFT commitment required (e.g. unique ID)
 *   ownerPkh             = fallback owner P2PKH for drain()
 */
contract MeanRevertSingleTokenNFTAuth(
    bytes   tokenCategory,
    int     targetTokenAmount,
    bytes   rebalancerNftCat,
    bytes   rebalancerNftCommit,
    bytes20 ownerPkh
) {
    /**
     * Rebalance (NFT-authorized)
     *
     * Rules:
     *  - Transaction MUST include at least one input with:
     *      * nftCommitment == rebalancerNftCommit
     *      * tokenAmount == 0 (pure NFT)
     *  - Performs mean-reversion check over FT holdings:
     *        |newTokens - target| <= |oldTokens - target|
     *
     * For this PoC we simply treat any non-zero tokenAmount as “the FT we
     * care about”, and ignore tokenCategory in the loops to keep things
     * robust with the current loops preview compiler.
     */
    function rebalance() {
        // Dummy no-ops to mark bytes params as "used" for the compiler.
        // These have no behavioural effect.
        require(rebalancerNftCat == rebalancerNftCat);
        require(tokenCategory == tokenCategory);

        // ---- NFT authority check (at least 1 matching NFT input) ----
        bool hasNftAuthority = false;
        int k = 0;

        do {
            // We only care about inputs that:
            //  - carry an NFT (tokenAmount == 0)
            //  - with the expected commitment
            if (tx.inputs[k].tokenAmount == 0) {
                if (tx.inputs[k].nftCommitment == rebalancerNftCommit) {
                    hasNftAuthority = true;
                }
            }

            k = k + 1;
        } while (k < tx.inputs.length);

        require(hasNftAuthority);

        // ---- INPUT token total (any non-zero FT amount) ----
        int i = 0;
        int oldTokens = 0;
        int contractInputs = 0;

        do {
            int inAmount = tx.inputs[i].tokenAmount;

            // Count any FT input (tokenAmount > 0).
            if (inAmount > 0) {
                oldTokens = oldTokens + inAmount;
                contractInputs = contractInputs + 1;
            }

            i = i + 1;
        } while (i < tx.inputs.length);

        // ---- OUTPUT token total (any non-zero FT amount) ----
        int j = 0;
        int newTokens = 0;
        int contractOutputs = 0;

        do {
            int outAmount = tx.outputs[j].tokenAmount;

            // Count any FT output (tokenAmount > 0).
            if (outAmount > 0) {
                newTokens = newTokens + outAmount;
                contractOutputs = contractOutputs + 1;
            }

            j = j + 1;
        } while (j < tx.outputs.length);

        // At least one FT output must exist.
        require(contractOutputs > 0);

        // ---- distance before ----
        int distBefore = oldTokens - targetTokenAmount;
        if (distBefore < 0) distBefore = -distBefore;

        // ---- distance after ----
        int distAfter = newTokens - targetTokenAmount;
        if (distAfter < 0) distAfter = -distAfter;

        // Mean-reversion invariant: new allocation must be at least as
        // close to target as the previous allocation.
        require(distAfter <= distBefore);
    }

    /**
     * Drain (owner P2PKH)
     *
     * Safety escape hatch: Alice (ownerPkh) can always fully empty
     * the contract, regardless of NFTs.
     */
    function drain(pubkey ownerPk, sig ownerSig) {
        require(hash160(ownerPk) == ownerPkh);
        require(checkSig(ownerSig, ownerPk));

        // No further constraints → free form spend:
        // all BCH + tokens can go straight back to Alice.
    }
}
