// contracts/MeanRevertSingleTokenNFTAuthV2.cash
pragma cashscript ^0.13.0;

/**
 * MeanRevertSingleTokenNFTAuthV2 (PoC – contract-centric mean reversion)
 *
 * - Tracks a single FT token category for *this contract*.
 * - Rebalance is permitted ONLY if caller provides an NFT with:
 *     * nftCommitment == rebalancerNftCommit
 *     * tokenAmount == 0 (pure NFT)
 *   (Capability and NFT category are still not enforced – kept for future tightening.)
 * - Mean-reversion is enforced on this contract’s FT position:
 *
 *       |newTokensOnContract - targetTokenAmount|
 *         <= |oldTokensOnContract - targetTokenAmount|
 *
 *   where:
 *     oldTokensOnContract = sum of FT amounts on inputs locked to this contract
 *     newTokensOnContract = sum of FT amounts on outputs locked to this contract
 *
 * Params:
 *   tokenCategory        = fungible token for portfolio (32-byte category ID)
 *   targetTokenAmount    = desired FT amount held by this contract
 *   rebalancerNftCat     = (reserved) NFT category (currently unused)
 *   rebalancerNftCommit  = NFT commitment required (e.g. unique ID)
 *   ownerPkh             = fallback owner P2PKH for drain()
 */
contract MeanRevertSingleTokenNFTAuthV2(
    bytes   tokenCategory,
    int     targetTokenAmount,
    bytes   rebalancerNftCat,
    bytes   rebalancerNftCommit,
    bytes20 ownerPkh
) {
    /**
     * Rebalance (NFT-authorized, contract-centric mean reversion)
     *
     * Note: This function **does not** forbid fully draining FTs from the
     * contract. It only enforces that the new FT position is at least as
     * close to `targetTokenAmount` as before. Strategy/oracle lives off-chain.
     */
    function rebalance() {
        // Dummy no-op to mark rebalancerNftCat as "used" for the compiler.
        require(rebalancerNftCat == rebalancerNftCat);

        // ---- NFT authority check (at least 1 matching NFT input) ----
        bool hasNftAuthority = false;
        int k = 0;

        do {
            // Inputs that:
            //  - carry an NFT (tokenAmount == 0)
            //  - with the expected commitment
            if (tx.inputs[k].tokenAmount == 0) {
                if (tx.inputs[k].nftCommitment == rebalancerNftCommit) {
                    hasNftAuthority = true;
                }
            }

            k = k + 1;
        } while (k < tx.inputs.length);

        require(hasNftAuthority);

        // ---- Determine this contract's locking bytecode ----
        //
        // The currently executing input index is this.activeInputIndex.
        // Its lockingBytecode is the script that identifies this contract's UTXOs.
        int contractIndex = this.activeInputIndex;
        bytes contractLock = tx.inputs[contractIndex].lockingBytecode;

        // ---- INPUT token total for this tokenCategory on *this contract* ----
        int i = 0;
        int oldTokensOnContract = 0;

        do {
            int inAmount = tx.inputs[i].tokenAmount;

            // Only bother with inputs that actually carry FTs
            if (inAmount > 0) {
                // tokenCategory introspection may contain more than just the 32-byte ID,
                // so normalize to the first 32 bytes before comparison.
                bytes fullInCategory = tx.inputs[i].tokenCategory;

                // Guard against malformed or empty tokenCategory
                if (fullInCategory.length >= 32) {
                    bytes inCategory = fullInCategory.split(32)[0];

                    // Only count FTs:
                    //  - with this tokenCategory (normalized)
                    //  - whose lockingBytecode matches this contract
                    if (inCategory == tokenCategory) {
                        if (tx.inputs[i].lockingBytecode == contractLock) {
                            oldTokensOnContract =
                                oldTokensOnContract + inAmount;
                        }
                    }
                }
            }

            i = i + 1;
        } while (i < tx.inputs.length);

        // ---- OUTPUT token total for this tokenCategory on *this contract* ----
        int j = 0;
        int newTokensOnContract = 0;

        do {
            int outAmount = tx.outputs[j].tokenAmount;

            // Only consider outputs that actually carry FTs
            if (outAmount > 0) {
                // Same normalization for outputs.
                bytes fullOutCategory = tx.outputs[j].tokenCategory;

                // Guard against malformed or empty tokenCategory
                if (fullOutCategory.length >= 32) {
                    bytes outCategory = fullOutCategory.split(32)[0];

                    if (outCategory == tokenCategory) {
                        if (tx.outputs[j].lockingBytecode == contractLock) {
                            newTokensOnContract =
                                newTokensOnContract + outAmount;
                        }
                    }
                }
            }

            j = j + 1;
        } while (j < tx.outputs.length);

        // NOTE:
        // - Fully draining FTs (newTokensOnContract == 0) is allowed
        //   as long as the mean-reversion inequality below still holds.

        // ---- distance before ----
        int distBefore = oldTokensOnContract - targetTokenAmount;
        if (distBefore < 0) distBefore = -distBefore;

        // ---- distance after ----
        int distAfter = newTokensOnContract - targetTokenAmount;
        if (distAfter < 0) distAfter = -distAfter;

        // New allocation must be at least as close to target
        require(distAfter <= distBefore);
    }

    /**
     * Drain (owner P2PKH)
     *
     * Safety escape hatch: Alice (ownerPkh) can always fully empty
     * the contract, regardless of NFTs.
     */
    function drain(pubkey ownerPk, sig ownerSig) {
        require(hash160(ownerPk) == ownerPkh);
        require(checkSig(ownerSig, ownerPk));

        // No further constraints → free form spend:
        // all BCH + tokens can go straight back to Alice.
    }
}
